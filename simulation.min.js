const SIMULATION_VERSION = "9.2.4"; class ClubRot { constructor() { this.list = [], this.clubRotSettingElement = document.getElementById("clubRotSetting"), this.clubRotSettingElement.innerHTML = "" } displayInput() { this.clubRotSettingElement.style.display = "block" } hiddenInput() { this.clubRotSettingElement.style.display = "none" } createInput(t) { this.clubRotSettingElement.innerHTML = "", this.clubRotSettingElement.innerHTML = "<h2>クラブの回転数を変更</h2>", this.list = []; let e = []; for (let a of t.data) for (let s of a.numData) e.push({ text: SiteswapProcessor.CONVERT[s.num] + (s.isCross ? "x" : ""), num: s.num }); for (let i = 0; i < e.length; i++) { let l = document.createElement("span"), n = document.createElement("select"); n.id = "clubRotSelector" + i, n.classList.add("clubSelectBox"); let r = document.createElement("label"); r.textContent = e[i].text, r.setAttribute("for", n.id); for (var o = 0; o <= 30; o++) { var c = document.createElement("option"); if (c.value = o, c.text = o, n.appendChild(c), 2 == e[i].num || 0 == e[i].num) break } n.value = Math.floor(e[i].num / 2), this.list.push(n.value), n.setAttribute("data-index", i), l.appendChild(r), l.appendChild(n), this.clubRotSettingElement.appendChild(l) } } changeList(t, e) { var a = document.querySelectorAll("[data-index='" + e + "']"); if (a.length > 0) { var s = a[0].value; this.list[e] = s } } getRot(t) { return Number(this.list[t]) } } class RingSetting { constructor() { this.list = [], this.ringSettingElement = document.getElementById("ringSetting"), this.ringSettingElement.innerHTML = "", this.optionList = ["ノーマル", "フラット", "アウター", "パンケーキ"] } displayInput() { this.ringSettingElement.style.display = "block" } hiddenInput() { this.ringSettingElement.style.display = "none" } createInput(t) { this.ringSettingElement.innerHTML = "", this.ringSettingElement.innerHTML = "<h2>リングの投げ方を変更</h2>", this.list = []; let e = []; for (let a of t.data) for (let s of a.numData) e.push({ text: SiteswapProcessor.CONVERT[s.num] + (s.isCross ? "x" : ""), num: s.num, prefix: a.prefix }); for (let i = 0; i < e.length; i++) { let l = document.createElement("span"), n = document.createElement("select"); n.id = "ringSelector" + i, n.classList.add("singSelectBox"); let r = document.createElement("label"); r.textContent = e[i].text, r.setAttribute("for", n.id); for (let o = 0; o < this.optionList.length && 0 != e[i].num; o++) { var c = document.createElement("option"); c.value = o, c.text = this.optionList[o], n.appendChild(c) } n.value = "/" == e[i].prefix || "+" == e[i].prefix ? 2 : 0, this.list.push("/" == e[i].prefix || "+" == e[i].prefix ? 2 : 0), n.setAttribute("data-index-ring", i), l.appendChild(r), l.appendChild(n), this.ringSettingElement.appendChild(l) } } changeList(t, e) { var a = document.querySelectorAll("[data-index-ring='" + e + "']"); if (a.length > 0) { var s = a[0].value; this.list[e] = s } } getSetting(t) { return this.list[t] } } class Display { constructor() { this.er = document.getElementById("er"), this.siteswapDisplay = document.getElementById("siteswapDisplay"), this.input = document.getElementById("siteswapInput"), this.lowFpsWarning = document.getElementById("low-fps-warning"), this.warningText = this.lowFpsWarning?.querySelector(".warning-text"), this.closeBtn = this.lowFpsWarning?.querySelector(".low-fps-warning-close-btn"), this.lowFpsWarningDisabled = !1, this.closeBtn && this.closeBtn.addEventListener("click", () => { this.closeFpsWarning() }) } init() { this.er && (this.er.value = ""), this.siteswapDisplay && (this.siteswapDisplay.value = "") } update(t, e, a) { this.er && (this.er.value = null === t ? "" : t), this.siteswapDisplay && (this.siteswapDisplay.value = a ? e : ""), this.input && this.input.classList.toggle("error-border", e && !a) } showLowFpsWarning(t, e) { t && !this.lowFpsWarningDisabled && this.lowFpsWarning ? (this.lowFpsWarning.style.display = "block", this.warningText && (this.warningText.textContent = `アニメーションが滑らかではない状態です。デバイスの低電力モードを無効にすると改善する場合があります。(FPS:${e})`)) : this.lowFpsWarning && (this.lowFpsWarning.style.display = "none") } closeFpsWarning() { this.lowFpsWarning && (this.lowFpsWarning.style.display = "none"), this.lowFpsWarningDisabled = !0 } updateInput(t) { this.input && (this.input.value = t) } } class Data { constructor(t, e, a, s, i, l, n, r, o, c) { this.validateInputs(t, e, a, s, i, l, n, r, o), this.num = t, this.xs = e, this.xg = a, this.x = s, this.y = i, this.isCross = l, this.index = n, this.prefix = r, this.count = o, this.handIndex = void 0 !== c ? c : null, this.yaw = this.calcYaw(!1), this.yawGoal = this.calcYaw(!0), this.roll = this.calcRoll(), this.validateCalculatedValues(), this.color = null, this.colorId = null, this.propIdList = null } calcRoll() { let t = this.num - 1, e = state.Y_INI - state.G_INI * (t + 1) ** 2 / state.maxHPa; 2 == this.num && (e = state.Y_INI - state.G_INI * (t + 25.5 / state.bodySize) ** 2 / state.maxHPa); let a = this.xs == this.xg, s = -(.5 * Math.tanh((this.xg - this.xs) / (state.Y_INI - e))); return a && (s = 0), s = Math.max(Math.min(s, state.rollLimit), -state.rollLimit) } calcYaw(t) { if (0 === this.num) return 0; let e = this.num - 1, a = state.Y_INI - state.G_INI * (e + 1) ** 2 / state.maxHPa; 2 == this.num && (a = state.Y_INI - state.G_INI * (e + 25.5 / state.bodySize) ** 2 / state.maxHPa); let s = -Math.tanh(1.5 * (this.xg - this.xs) / (state.Y_INI - a)); this.isCross || this.num % 2 != 0 || "+" != this.prefix ? this.isCross || this.num % 2 != 0 || "-" != this.prefix ? "/" == this.prefix ? s = -s : (this.isCross && "+" == this.prefix || !this.isCross && this.num % 2 != 0 && "+" == this.prefix) && (s = -s / 2) : s = -Math.tanh(.3 * (state.xCenter - this.xs) / (state.Y_INI - a)) : s = -Math.tanh(1.5 * (this.xs - state.xCenter) / (state.Y_INI - a)), 1 == this.num && (s = -Math.tanh(1.5 * (this.xg - state.xCenter) / (state.Y_INI - a)), "/" == this.prefix && (s = -s)), s = Math.max(Math.min(s, state.yawLimit), -state.yawLimit); let i = this.xs == this.xg; if (2 == this.num && !i) { let l = (this.xs + this.xg) / 2; s = t ? (l - this.xg) / Math.abs(this.xs - l) * state.yawLimit : (l - this.xs) / Math.abs(this.xs - l) * state.yawLimit } return s } updateGripYaw(t, e) { this.yaw = t, this.yawGoal = e } validateInputs(t, e, a, s, i, l, n, r, o) { let c = []; this.isInteger(t) || c.push(`_numは整数である必要があります。受け取った値: ${t} (型: ${typeof t})`), this.isNumber(e) || c.push(`_xsは数値である必要があります。受け取った値: ${e} (型: ${typeof e})`), this.isNumber(a) || c.push(`_xgは数値である必要があります。受け取った値: ${a} (型: ${typeof a})`), this.isNumber(s) || c.push(`_xは数値である必要があります。受け取った値: ${s} (型: ${typeof s})`), this.isNumber(i) || c.push(`_yは数値である必要があります。受け取った値: ${i} (型: ${typeof i})`), "boolean" != typeof l && c.push(`_isCrossはboolean型である必要があります。受け取った値: ${l} (型: ${typeof l})`), this.isInteger(n) || c.push(`_indexは整数である必要があります。受け取った値: ${n} (型: ${typeof n})`), this.isSingleCharString(r) || c.push(`_prefixは一文字の文字列である必要があります。受け取った値: ${r} (型: ${typeof r})`), this.isInteger(o) || c.push(`_countは整数である必要があります。受け取った値: ${o} (型: ${typeof o})`), c.length > 0 && (console.warn("【型検証エラー】Dataクラスのコンストラクタ引数:"), c.forEach(t => console.warn(`  - ${t}`))) } validateCalculatedValues() { let t = []; this.isNumber(this.yaw) || t.push(`yawは数値である必要があります。計算結果: ${this.yaw} (型: ${typeof this.yaw})`), this.isNumber(this.yawGoal) || t.push(`yawGoalは数値である必要があります。計算結果: ${this.yawGoal} (型: ${typeof this.yawGoal})`), this.isNumber(this.roll) || t.push(`rollは数値である必要があります。計算結果: ${this.roll} (型: ${typeof this.roll})`), t.length > 0 && (console.warn("【型検証エラー】Dataクラスの計算結果:"), t.forEach(t => console.warn(`  - ${t}`))) } isInteger(t) { return "number" == typeof t && Number.isInteger(t) && !isNaN(t) } isNumber(t) { return "number" == typeof t && !isNaN(t) && isFinite(t) } isSingleCharString(t) { return "string" == typeof t && 1 === t.length } } class HandData extends Data { static POSITION = { LEFT: "left", RIGHT: "right" }; static DIRECTION = { UP: "up", DOWN: "down" }; constructor(t, e, a, s, i, l, n, r, o, c, u) { super(t, e, a, s, i, l, n, r, o), this.where = { horizontal: c, vertical: u } } } class DataProcessor { static createSimuData(t, e) { if (t.isAsync) { let a = t.data[e % t.data.length], s = a.prefix, i = t.data[(e + 1) % t.data.length].prefix, l = "+" == s || "#" == s, n = (e % 2 ? 0 : 2) + (e % 2 != ("+" == s || "/" == s) ? 1 : 0), r = state.x[n], o = state.x[((e + 1) % 2 ? 0 : 2) + ((e + 1) % 2 != ("+" == i || "/" == i) ? 1 : 0)], c = []; for (let u of a.numData) { let d = u.num, h = u.index, m = 1 == d ? o : state.airborneStates[d] ? state.airborneStates[d].xg : this.categorize(e % 2, d % 2, l), p = new Data(d, r, m, 0, state.Y_INI, !1, h, s, e, n); state.airborneStates[d] || (state.airborneStates[d] = p), p = DataProcessor.updateAsyncSimuDataYaw(d, t, e, p, state.airborneStates[d]), c.push(p) } return c } { let g = [t.data[e % t.data.length].numData, t.data[(e + 1) % t.data.length].numData], x = [t.data[e % t.data.length].prefix, t.data[(e + 1) % t.data.length].prefix], y = ["+" == x[0] || "/" == x[0], "+" == x[1] || "/" == x[1]], b = ["+" == x[0] || "#" == x[0], "+" == x[1] || "#" == x[1]], I = [state.x[y[0] ? 0 : 1], state.x[y[1] ? 3 : 2]], S = [y[0] ? 0 : 1, y[1] ? 3 : 2], $ = []; for (let C of [0, 1]) for (let D of g[C]) { let f = D.isCross, _ = this.categorizeSync(C, f, b[C]); state.airborneStates[D.num / 2] && (!state.airborneStates[D.num / 2] || state.airborneStates[D.num / 2][f ? -(C - 1) : C]) ? $.push(new Data(D.num, I[C], state.airborneStates[D.num / 2][f ? -(C - 1) : C].xg, 0, state.Y_INI, f, D.index, x[C], e, S[C])) : (state.airborneStates[D.num / 2] || (state.airborneStates[D.num / 2] = []), state.airborneStates[D.num / 2][f ? -(C - 1) : C] = new Data(D.num, I[C], _, 0, state.Y_INI, f, D.index, x[C], e, S[C]), $.push(new Data(D.num, I[C], _, 0, state.Y_INI, f, D.index, x[C], e, S[C]))) } return $ } } static categorize = (t, e, a) => state.x[(t == e ? 2 : 0) + (t == e == a ? 1 : 0)]; static categorizeSync = (t, e, a) => state.x[(t == e ? 0 : 2) + (t != e == a ? 1 : 0)]; static createSimuGripData(t, e, a, s) { if (e.isAsync) { let i = e.data[a % e.data.length].numData[0].num, l = e.data[a % e.data.length].numData[0].index, n = e.data[a % e.data.length].prefix, r = (a % 2 ? 0 : 2) + (a % 2 != ("+" == n || "/" == n) ? 1 : 0), o = state.x[r], c = new Data(i, t.xg, o, 0, state.Y_INI, !1, l, n, a, r), u = DataProcessor.getSimuData(e, a)[0]; return c.updateGripYaw(t.yawGoal, u.yaw), c } { let d = [e.data[a % e.data.length].numData, e.data[(a + 1) % e.data.length].numData], h = [e.data[a % e.data.length].prefix, e.data[(a + 1) % e.data.length].prefix], m = ["+" == h[0] || "/" == h[0], "+" == h[1] || "/" == h[1]], p = [state.x[m[0] ? 0 : 1], state.x[m[1] ? 3 : 2]], g = [m[0] ? 0 : 1, m[1] ? 3 : 2], x = new Data(d[s][0].num, t.xg, p[s], 0, state.Y_INI, !1, d[s][0].index, h[s], a, g[s]), y = DataProcessor.getSimuData(e, a, s)[0]; return x.updateGripYaw(t.yawGoal, y.yaw), x } } static createSimuHandData(t, e, a, s, i, l) { let n = a; if (e.isAsync) { let r = e.data[a % e.data.length].numData[0].num, o = e.data[a % e.data.length].numData[0].index, c = e.data[a % e.data.length].prefix, u = state.x[(a % 2 ? 0 : 2) + (a % 2 != ("+" == c || "/" == c) ? 1 : 0)], d = t ? 1 == t.num ? state.x[a % 2 ? 0 : 3] : t.xg : state.x[a % 2 ? 0 : 3]; a -= 1; let h = e.data[a % e.data.length].numData[0].num, m = e.data[a % e.data.length].numData[0].index, p = e.data[a % e.data.length].prefix, g = state.x[(a % 2 ? 0 : 2) + (a % 2 != ("+" == p || "/" == p) ? 1 : 0)], x = s ? s.xg : state.x[a % 2 ? 0 : 3]; return [new HandData(r, d, u, 0, state.Y_INI, !1, o, c, n, a % 2 ? HandData.POSITION.LEFT : HandData.POSITION.RIGHT, HandData.DIRECTION.DOWN), new HandData(h, g, x, 0, state.Y_INI, !1, m, p, n, a % 2 ? HandData.POSITION.RIGHT : HandData.POSITION.LEFT, HandData.DIRECTION.UP)] } { if (l) { let y = [e.data[a % e.data.length].numData, e.data[(a + 1) % e.data.length].numData], b = [e.data[a % e.data.length].prefix, e.data[(a + 1) % e.data.length].prefix], I = ["+" == b[0] || "/" == b[0], "+" == b[1] || "/" == b[1]], S = [state.x[I[0] ? 0 : 1], state.x[I[1] ? 3 : 2]], $ = t[1] && t[1][i] ? t[1][i].xg : state.x[i ? 3 : 0]; return new HandData(y[i][0].num, S[i], $, 0, state.Y_INI, !1, y[i][0].index, b[i], n, i ? HandData.POSITION.LEFT : HandData.POSITION.RIGHT, HandData.DIRECTION.UP) } let C = [e.data[a % e.data.length].numData, e.data[(a + 1) % e.data.length].numData], D = [e.data[a % e.data.length].prefix, e.data[(a + 1) % e.data.length].prefix], f = ["+" == D[0] || "/" == D[0], "+" == D[1] || "/" == D[1]], _ = [state.x[f[0] ? 0 : 1], state.x[f[1] ? 3 : 2]], w = t[1] && t[1][i] ? t[1][i].xg : state.x[i ? 3 : 0]; return new HandData(C[i][0].num, w, _[i], 0, state.Y_INI, !1, C[i][0].index, D[i], n, i ? HandData.POSITION.LEFT : HandData.POSITION.RIGHT, HandData.DIRECTION.DOWN) } } static getSimuData(t, e, a = null, s = 0) { if (t.isAsync) { let i = t.data[e % t.data.length], l = i.prefix, n = t.data[(e + 1) % t.data.length].prefix, r = "+" == l || "#" == l, o = (e % 2 ? 0 : 2) + (e % 2 != ("+" == l || "/" == l) ? 1 : 0), c = state.x[o], u = state.x[((e + 1) % 2 ? 0 : 2) + ((e + 1) % 2 != ("+" == n || "/" == n) ? 1 : 0)], d = []; for (let h of i.numData) { let m = h.num, p = h.index, g = 1 == m ? u : state.airborneStates[m + 1] ? state.airborneStates[m + 1].xg : this.categorize(e % 2, m % 2, r), x = new Data(m, c, g, 0, state.Y_INI, !1, p, l, e, o); x = DataProcessor.updateAsyncSimuDataYaw(m, t, e, x, state.airborneStates[m + 1], s), d.push(x) } return d } { let y = [t.data[e % t.data.length].numData, t.data[(e + 1) % t.data.length].numData], b = [t.data[e % t.data.length].prefix, t.data[(e + 1) % t.data.length].prefix], I = ["+" == b[0] || "/" == b[0], "+" == b[1] || "/" == b[1]], S = ["+" == b[0] || "#" == b[0], "+" == b[1] || "#" == b[1]], $ = [state.x[I[0] ? 0 : 1], state.x[I[1] ? 3 : 2]], C = [I[0] ? 0 : 1, I[1] ? 3 : 2], D = []; for (let f of y[a]) { let _ = f.isCross, w = this.categorizeSync(a, _, S[a]); state.airborneStates[(f.num + 2) / 2] && (!state.airborneStates[(f.num + 2) / 2] || state.airborneStates[(f.num + 2) / 2][_ ? -(a - 1) : a]) ? D.push(new Data(f.num, $[a], state.airborneStates[(f.num + 2) / 2][_ ? -(a - 1) : a].xg, 0, state.Y_INI, _, f.index, b[a], e, C[a])) : D.push(new Data(f.num, $[a], w, 0, state.Y_INI, _, f.index, b[a], e, C[a])) } return D } } static updateAsyncSimuDataYaw(t, e, a, s, i, l = 0) { if (l > 0) return s; if (1 == t) { let n = DataProcessor.getSimuData(e, a + 1, null, l + 1)[0]; s.updateGripYaw(s.yaw, n.yaw) } else i && s.updateGripYaw(s.yaw, i.yawGoal); return s } } class State { constructor() { this.DEFAULT_CONFIG = { colors: { background: "#5a5a5a", object: "#FFFFFF", player: "#000000", text: "#FFFFFF" }, object: { selected: "ball", types: { ball: { value: "ball", displayName: "ボール" }, ring: { value: "ring", displayName: "リング" }, club: { value: "club", displayName: "クラブ" }, comet: { value: "comet", displayName: "コメット" } } }, visibility: { showPlayer: !0, showText: !1, showBottomText: !1, randomColor: !1 }, animation: { speedInput: 100, continueDuringCameraMove: !1, enableTimeoutStop: !0 }, camera: { positionXInput: 0, positionXInputForRing: 0 }, physics: { initialY: 395, gravity: 10, maxHeight: 40, yawLimit: .15, rollLimit: .05 } }, this.setInitOption(), this.reset() } setInitOption() { let t = this.DEFAULT_CONFIG; this.backgroundColor = t.colors.background, this.objectColor = t.colors.object, this.playerColor = t.colors.player, this.textColor = t.colors.text, this.isPlayerVisible = t.visibility.showPlayer, this.isTextVisible = t.visibility.showText, this.isBottomTextVisible = t.visibility.showBottomText, this.isRandomColor = t.visibility.randomColor, this.objectSelect = t.object.selected, this.setViewSpeed(t.animation.speedInput), this.isNotStopWhenMovCam = t.animation.continueDuringCameraMove, this.enableTimeoutStop = t.animation.enableTimeoutStop, this.setCamPosX(t.camera.positionXInput) } reset() { let t = this.DEFAULT_CONFIG.physics; this.Y_INI = t.initialY, this.G_INI = t.gravity, this.maxh = t.maxHeight, this.yawLimit = t.yawLimit, this.rollLimit = t.rollLimit, this.x = [null, null, null, null], this.x3mag = null, this.x4mag = null, this.maxnum = null, this.maxHPa = null, this.ballSize = null, this.xCenter = null, this.isValidated = !1, this.isJugglable = !1, this.pattern = null, this.patternData = null, this.clubRot = new ClubRot, this.ringSetting = new RingSetting, this.simuData = [], this.airborneStates = [], this.simuHandData = [], this.simuGripData = [], this.centerX = width / 2, this.camPosZ = -(30 * (width / 2)), this.colorList = [], this.propList = [] } setData(t) { console.log(t), this.isValidated = t.isValidated, this.isJugglable = t.isJugglable, this.pattern = t.pattern, this.patternData = t.patternData, this.colorList = Color.createInitialData(t.patternData.propCount), this.propList = Prop.createInitialData(t.patternData.propCount) } createIniAnimeData() { this.clubRot.createInput(this.patternData), this.ringSetting.createInput(this.patternData), this.maxnum = this.patternData.maxHeight, this.x[1] = Math.floor(width / 2 - 170 / (this.maxnum >= 5 ? this.maxnum : 5)), this.x[2] = Math.floor(width / 2 + 170 / (this.maxnum >= 5 ? this.maxnum : 5)), this.x[3] = Math.floor((this.x[2] - width / 2) * 1.5 + this.x[2]), this.x[0] = Math.floor(this.x[1] - (this.x[2] - width / 2) * 1.5), this.xCenter = (this.x[1] + this.x[2]) / 2, this.maxHPa = this.G_INI * (this.maxnum >= 5 ? this.maxnum : 5) ** 2 / (this.Y_INI - this.maxh), this.x3mag = width / 2 + 170 / (this.maxnum >= 5 ? this.maxnum : 5), this.x4mag = (this.x3mag - width / 2) * 1.5 + this.x[2], this.ballSize = this.maxnum >= 5 ? 80 / this.maxnum : 16, this.lineSize = (this.x4mag - this.x3mag) / 5, this.bodySize = this.x4mag - this.x3mag } setViewSpeed(t) { this.viewSpeed = (t / 100) ** 2 * 3 } setZeroViewSpeed() { this.viewSpeed = 0 } setCamPosX(t) { this.camPosX = -t / 100 } } class Animation { static VERSION = "1.0.5"; constructor() { this.frame = this.frame.bind(this), this.frameTimings = [], this.framesToAverage = 60, this._cachedAvgProcessTime = 0, this.fpsStartTime = 0, this.fpsFrameCount = 0 } init() { this.lastTime = null, this.count = 0, this.sumTime = 1, this.lastSumTime = 0, this.diffTime = 0, this.frameTimings = [], this._cachedAvgProcessTime = 0, this.fpsStartTime = performance.now(), this.fpsFrameCount = 0 } get avgProcessTime() { return this._cachedAvgProcessTime } updateFps() { this.fpsFrameCount++; let t = performance.now(), e = t - this.fpsStartTime; if (e >= 1e3) { let a = Math.round(1e3 * this.fpsFrameCount / e); display.showLowFpsWarning(a < 40, a), this.fpsStartTime = t, this.fpsFrameCount = 0 } } start(t) { this.init(), display.init(), state.reset(); let e = new SiteswapProcessor, a = SiteswapProcessor.normalizePattern(t.trim()), s = e.validate(a); display.update(s.message, a, s.isJugglable), state.setData(e), console.log(state), state.isJugglable ? (state.createIniAnimeData(), log.timeStart(a)) : log.timeClear(), patternFeatures.update(a, s.isJugglable) } calculateAverageProcessTime() { if (0 === this.frameTimings.length) return 0; let t = this.frameTimings.reduce((t, e) => t + e, 0); return t / this.frameTimings.length } frame(t) { this.updateFps(); let e = performance.now(); if (ctx.clearRect(0, 0, width, height), state.isJugglable) { this.lastTime || (this.lastTime = t); let a = (t - this.lastTime) / 1e3; if (a > .5) { console.warn("Large frame gap detected, resetting animation state"), this.lastTime = t, requestAnimationFrame(this.frame); return } this.lastTime = t, state.simuData = state.simuData.filter(t => t.y <= state.Y_INI), state.simuGripData = state.simuGripData.filter(t => t.y >= state.Y_INI), state.simuHandData = state.simuHandData.filter(t => t.y >= state.Y_INI && t.where.vertical === HandData.DIRECTION.DOWN || t.y <= state.Y_INI && t.where.vertical === HandData.DIRECTION.UP), Draw.playerBody(); for (let s = 0; s < state.simuHandData.length; s++)Draw.playerHand(state.simuHandData[s], a, s, this.sumTime - this.lastSumTime); if (0 == state.simuHandData.length && 0 == state.viewSpeed && Draw.playerHandInit(), Draw.renderObjectsWithDepthSorting(a, this.sumTime - this.lastSumTime), state.isBottomTextVisible && Draw.bottomText(state.pattern), this.sumTime += a * state.viewSpeed, this.sumTime - this.lastSumTime > 1) { if (state.simuHandData = [], state.simuGripData = [], state.patternData.isAsync) { state.airborneStates.shift(); let i = DataProcessor.createSimuData(state.patternData, this.count).filter(t => 0 !== t.num); for (let l of i) Color.assignColorToItem(l, state.colorList, !0), Prop.assignPropIdToItem(l, state.propList, !0), state.simuData.push(l); if (state.airborneStates[1] && 1 != state.airborneStates[1].num) { let n = DataProcessor.createSimuGripData(state.airborneStates[1], state.patternData, this.count + 1); Color.getColorForGripItem(n, state.colorList, !0), Prop.getPropIdForGripItem(n, state.propList, !0), state.simuGripData.push(n) } state.simuHandData.push(...DataProcessor.createSimuHandData(state.airborneStates[1], state.patternData, this.count + 1, state.airborneStates[2])) } else if (this.count % 2) for (let r of [0, 1]) { if (state.airborneStates[1] && state.airborneStates[1][r]) { let o = DataProcessor.createSimuGripData(state.airborneStates[1][r], state.patternData, this.count + 1, r); Color.getColorForGripItem(o, state.colorList, !1), Prop.getPropIdForGripItem(o, state.propList, !1), state.simuGripData.push(o) } state.simuHandData.push(DataProcessor.createSimuHandData(state.airborneStates, state.patternData, this.count + 1, state.airborneStates, r)) } else { state.airborneStates.shift(); let c = DataProcessor.createSimuData(state.patternData, this.count).filter(t => 0 !== t.num); for (let u of c) Color.assignColorToItem(u, state.colorList, !1), Prop.assignPropIdToItem(u, state.propList, !1), state.simuData.push(u); for (let d of [0, 1]) state.simuHandData.push(DataProcessor.createSimuHandData(state.airborneStates, state.patternData, this.count, state.airborneStates, d, !0)) } this.count += 1, this.diffTime = this.sumTime - this.lastSumTime, this.lastSumTime = this.sumTime, this.diffTime > 2 && this.start(state.pattern) } } let h = performance.now() - e; this.frameTimings.push(h), this.frameTimings.length > this.framesToAverage && this.frameTimings.shift(), this._cachedAvgProcessTime = this.calculateAverageProcessTime(), this.avgProcessTime > 16 && state.enableTimeoutStop && (null !== state.pattern && "" !== state.pattern && alert(`1フレームの平均処理時間が 16ms を超えたため、シミュレーションをストップしました。(こちらのメッセージは大量のオブジェクトのシミュレーションによってデバイスに負荷がかかっている場合や、長時間ページから離れていた場合に表示されることがあります。)`), this.start("")), requestAnimationFrame(this.frame) } load() { requestAnimationFrame(this.frame) } } class Draw { static VERSION = "1.0.5"; static clubShape = [3, .29, 1.6, -.3, .4, 1.8, .6, 2.75, .35, 2.9, .12, 2.5, .28, 1.8, .62, 1.2, 2.3, .5, 1.25, .5, .8, .4]; static body_z = [1.2, 1.6]; static addBall(t, e, a, s, i) { let [l, n, r, o] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, i, e, !1); r <= state.Y_INI && (ctx.lineWidth = state.lineSize, ctx.strokeStyle = state.objectColor, ctx.fillStyle = state.objectColor, state.isRandomColor && t.color && (ctx.fillStyle = t.color), ctx.beginPath(), ctx.arc(Camera.projectToScreenX(l, 0), r, a, 0, 2 * Math.PI), ctx.fill(), state.isTextVisible && (ctx.fillStyle = state.textColor, ctx.font = "30px serif", ctx.fillText(String(SiteswapProcessor.CONVERT[t.num]) + (t.isCross ? "x" : ""), Camera.projectToScreenX(l, 0) + a * (1 + .1 * Math.abs(state.camPosX)), r))), state.simuData[s].x = n - t.xs, state.simuData[s].y = r } static addBallGrip(t, e, a, s, i) { let [l, n, r, o] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, i, e, !0); ctx.lineWidth = state.lineSize, ctx.strokeStyle = state.objectColor, ctx.fillStyle = state.objectColor, state.isRandomColor && t.color && (ctx.fillStyle = t.color), ctx.beginPath(), ctx.arc(Camera.projectToScreenX(l, 0), r, a, 0, 2 * Math.PI), ctx.fill(), state.simuGripData[s].x = n - t.xs, state.simuGripData[s].y = r } static ring(t, e, a, s, i = 0, l = null) { function n(t, e, a) { let s = [0, 0 * Math.cos(e) - 1 * Math.sin(e), 0 * Math.sin(e) + 1 * Math.cos(e)], i = [s[0] * Math.cos(a) + s[2] * Math.sin(a), s[1], -s[0] * Math.sin(a) + s[2] * Math.cos(a)], l = Math.abs(i[2]), n = Math.atan2(i[1], i[0]); return 1e-10 > Math.abs(i[0]) && 1e-10 > Math.abs(i[1]) && (n = 0), { majorAxis: t, minorAxis: t * l, rotationAngle: n } } let r = Math.abs(Math.sin(Math.PI * state.camPosX / 2 + i)), o = n(2.3 * a, Math.PI * s / 2, Math.PI * state.camPosX / 2 + Math.PI / 2 + i), c = n(1.7 * a, Math.PI * s / 2, Math.PI * state.camPosX / 2 + Math.PI / 2 + i); ctx.lineWidth = .2 * a; let u = l || state.objectColor; ctx.strokeStyle = u, ctx.fillStyle = u, ctx.beginPath(), ctx.ellipse(t, e, o.minorAxis, o.majorAxis, o.rotationAngle, 0, 2 * Math.PI), ctx.stroke(), ctx.lineWidth = .1 * a, ctx.beginPath(), ctx.ellipse(t - .1 * a * (1 - r), e, c.minorAxis, c.majorAxis, c.rotationAngle, 0, 2 * Math.PI), ctx.ellipse(t - .1 * a * (1 - r), e, o.minorAxis, o.majorAxis, o.rotationAngle, 0, 2 * Math.PI, !0), ctx.fill(), ctx.beginPath(), ctx.ellipse(t + .1 * a * (1 - r), e, c.minorAxis, c.majorAxis, c.rotationAngle, 0, 2 * Math.PI), ctx.ellipse(t + .1 * a * (1 - r), e, o.minorAxis, o.majorAxis, o.rotationAngle, 0, 2 * Math.PI, !0), ctx.fill() } static addRing(t, e, a, s, i) { let [l, n, r, o] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, i, e, !1), c = state.ringSetting.getSetting(t.index), u = PhysicsCalculator.calculateRingRotation(t.num, t.xs, o, t.xs + t.x), d = t.roll, h = state.isRandomColor && t.color ? t.color : null; if (r <= state.Y_INI) { if (0 == c) Draw.ring(Camera.projectToScreenX(l, -(1.2 * a)), r, a, d, 0, h), state.isTextVisible && (ctx.fillStyle = state.textColor, ctx.font = "30px serif", ctx.fillText(String(SiteswapProcessor.CONVERT[t.num]) + (t.isCross ? "x" : ""), Camera.projectToScreenX(l, -(1.2 * a)) + a * (1 + 2 * Math.abs(Math.sin(Math.PI * state.camPosX / 2))), r)); else if (1 == c) d = 1, Draw.ring(Camera.projectToScreenX(l, -(1.2 * a)), r, a, d, 0, h), state.isTextVisible && (ctx.fillStyle = state.textColor, ctx.font = "30px serif", ctx.fillText(String(SiteswapProcessor.CONVERT[t.num]) + (t.isCross ? "x" : ""), Camera.projectToScreenX(l, -(1.2 * a)) + a * (1 + 2 * Math.abs(Math.sin(Math.PI / 2))), r)); else if (2 == c) { d = 0; let m = 2 * a * (1 - t.x / o) - a; Draw.ring(Camera.projectToScreenX(l, m), r, a, d, Math.PI / 2, h), state.isTextVisible && (ctx.fillStyle = state.textColor, ctx.font = "30px serif", ctx.fillText(String(SiteswapProcessor.CONVERT[t.num]) + (t.isCross ? "x" : ""), Camera.projectToScreenX(l, m) + a * (1 + 2 * Math.abs(Math.sin(Math.PI * (1 - state.camPosX) / 2))), r)) } else 3 == c && (Draw.ring(Camera.projectToScreenX(l, -(1.2 * a)), r, a, -u + 1, Math.PI / 2, h), state.isTextVisible && (ctx.fillStyle = state.textColor, ctx.font = "30px serif", ctx.fillText(String(SiteswapProcessor.CONVERT[t.num]) + (t.isCross ? "x" : ""), Camera.projectToScreenX(l, -(1.2 * a)) + a * (1 + 2 * Math.abs(Math.sin(Math.PI / 2))), r))) } state.simuData[s].x = n - t.xs, state.simuData[s].y = r } static addRingGrip(t, e, a, s, i) { let [l, n, r, o] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, i, e, !0), c = Array.isArray(t.index) ? t.index[0] : t.index, u = state.ringSetting.getSetting(c), d = state.isRandomColor && t.color ? t.color : null; if (0 == u) Draw.ring(Camera.projectToScreenX(l, -(1.2 * a)), r, a, 0, 0, d); else if (1 == u) { let h = -(state.Y_INI - r) / (6 * Math.pow(a, .8)) + 1; Draw.ring(Camera.projectToScreenX(l, -(1.2 * a)), r - (state.Y_INI - r) / 3, a, h, Math.PI / 2, d) } else if (2 == u) { let m = -2 * a * (1 - t.x / o) + a; Draw.ring(Camera.projectToScreenX(l, m), r - (state.Y_INI - r) / 2, a, 0, Math.PI / 2, d) } else if (3 == u) { let p = -(state.Y_INI - r) / (6 * Math.pow(a, .8)) + 1; Draw.ring(Camera.projectToScreenX(l, -(1.2 * a)), r - (state.Y_INI - r) / 3, a, p, Math.PI / 2, d) } state.simuGripData[s].x = n - t.xs, state.simuGripData[s].y = r } static club(t, e, a, s, i, l, n = null, r = null) { a += .5; let o = Math.sin(Math.PI * l / 2); i && (a = state.Y_INI - e > 0 ? (state.Y_INI - e) / (50 * Math.pow(s, .8)) + .5 : (state.Y_INI - e) / (Math.pow(s, .8) * (2 == n ? 50 : 19)) + .5, e -= Math.pow(s, .8) * Math.sin(2 * Math.PI * (a + .5)) * 3); let c = Math.sqrt(Math.sin(2 * Math.PI * a) * Math.sin(2 * Math.PI * a) + o * o * Math.cos(2 * Math.PI * a) * Math.cos(2 * Math.PI * a)), u = Math.atan2(Math.sin(2 * Math.PI * a), o * Math.cos(2 * Math.PI * a)); ctx.lineWidth = 5 * state.lineSize / 8; let d = r || state.objectColor; ctx.strokeStyle = d, ctx.fillStyle = d, ctx.beginPath(), ctx.ellipse(t + s * Draw.clubShape[13] * o * Math.cos(2 * Math.PI * a), e + s * Draw.clubShape[13] * Math.sin(2 * Math.PI * a), s * Draw.clubShape[14], s * Draw.clubShape[15] * c, u + Math.PI / 2, 0, 2 * Math.PI), ctx.fill(), ctx.beginPath(), ctx.arc(t - s * Draw.clubShape[0] * o * Math.cos(2 * Math.PI * a), e - s * Draw.clubShape[0] * Math.sin(2 * Math.PI * a), s * Draw.clubShape[1], 0, 2 * Math.PI), ctx.fill(), ctx.beginPath(), ctx.moveTo(t + s * Draw.clubShape[2] * o * Math.cos(2 * Math.PI * a), e + s * Draw.clubShape[2] * Math.sin(2 * Math.PI * a)), ctx.lineTo(t - s * Draw.clubShape[0] * o * Math.cos(2 * Math.PI * a), e - s * Draw.clubShape[0] * Math.sin(2 * Math.PI * a)), ctx.stroke(), ctx.beginPath(), ctx.moveTo(t + s * Draw.clubShape[2] * o * Math.cos(2 * Math.PI * a) + Draw.clubShape[4] * s * Math.sin(2 * Math.PI * a) / c, e + s * Draw.clubShape[2] * Math.sin(2 * Math.PI * a) + -(Draw.clubShape[4] * s * o) * Math.cos(2 * Math.PI * a) / c), ctx.lineTo(t + s * Draw.clubShape[3] * o * Math.cos(2 * Math.PI * a), e + s * Draw.clubShape[3] * Math.sin(2 * Math.PI * a)), ctx.lineTo(t + s * Draw.clubShape[2] * o * Math.cos(2 * Math.PI * a) - Draw.clubShape[4] * s * Math.sin(2 * Math.PI * a) / c, e + s * Draw.clubShape[2] * Math.sin(2 * Math.PI * a) - -(Draw.clubShape[4] * s * o) * Math.cos(2 * Math.PI * a) / c), ctx.stroke(), ctx.beginPath(), ctx.moveTo(t + s * Draw.clubShape[11] * o * Math.cos(2 * Math.PI * a) - Draw.clubShape[12] * s * Math.sin(2 * Math.PI * a) / c, e + s * Draw.clubShape[11] * Math.sin(2 * Math.PI * a) - -(Draw.clubShape[12] * s * o) * Math.cos(2 * Math.PI * a) / c), ctx.lineTo(t + s * Draw.clubShape[9] * o * Math.cos(2 * Math.PI * a) - Draw.clubShape[10] * s * Math.sin(2 * Math.PI * a) / c, e + s * Draw.clubShape[9] * Math.sin(2 * Math.PI * a) - -(Draw.clubShape[10] * s * o) * Math.cos(2 * Math.PI * a) / c), ctx.lineTo(t + s * Draw.clubShape[9] * o * Math.cos(2 * Math.PI * a) + Draw.clubShape[10] * s * Math.sin(2 * Math.PI * a) / c, e + s * Draw.clubShape[9] * Math.sin(2 * Math.PI * a) + -(Draw.clubShape[10] * s * o) * Math.cos(2 * Math.PI * a) / c), ctx.lineTo(t + s * Draw.clubShape[11] * o * Math.cos(2 * Math.PI * a) + Draw.clubShape[12] * s * Math.sin(2 * Math.PI * a) / c, e + s * Draw.clubShape[11] * Math.sin(2 * Math.PI * a) + -(Draw.clubShape[12] * s * o) * Math.cos(2 * Math.PI * a) / c), ctx.stroke(), ctx.beginPath(), ctx.arc(t + s * Draw.clubShape[5] * o * Math.cos(2 * Math.PI * a), e + s * Draw.clubShape[5] * Math.sin(2 * Math.PI * a), s * Draw.clubShape[6], 0, 2 * Math.PI), ctx.fill(), animation.avgProcessTime < 7 && (ctx.beginPath(), ctx.arc(t + s * Draw.clubShape[7] * o * Math.cos(2 * Math.PI * a), e + s * Draw.clubShape[7] * Math.sin(2 * Math.PI * a), s * Draw.clubShape[8], 0, 2 * Math.PI), ctx.fill(), ctx.beginPath(), ctx.arc(t + s * Draw.clubShape[16] * o * Math.cos(2 * Math.PI * a), e + s * Draw.clubShape[16] * Math.sin(2 * Math.PI * a), s * Draw.clubShape[17], 0, 2 * Math.PI), ctx.fill(), ctx.beginPath(), ctx.arc(t + s * Draw.clubShape[18] * o * Math.cos(2 * Math.PI * a), e + s * Draw.clubShape[18] * Math.sin(2 * Math.PI * a), s * Draw.clubShape[19], 0, 2 * Math.PI), ctx.fill(), ctx.beginPath(), ctx.arc(t + s * Draw.clubShape[20] * o * Math.cos(2 * Math.PI * a), e + s * Draw.clubShape[20] * Math.sin(2 * Math.PI * a), s * Draw.clubShape[21], 0, 2 * Math.PI), ctx.fill()) } static addClub(t, e, a, s, i) { let [l, n, r, o] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, i, e, !1), c = state.clubRot.getRot(t.index), u = PhysicsCalculator.calculateClubRotation(c, t.xs, o, t.xs + t.x), d = PhysicsCalculator.calculateClubYaw(t.yaw, t.yawGoal, t.xs, o, t.xs + t.x), h = state.isRandomColor && t.color ? t.color : null; r <= state.Y_INI && (Draw.club(Camera.projectToScreenX(l, -a), r, u, a, 2 == t.num, d, t.num, h), state.isTextVisible && (ctx.fillStyle = state.textColor, ctx.font = "30px serif", ctx.fillText(String(SiteswapProcessor.CONVERT[t.num]) + (t.isCross ? "x" : ""), Camera.projectToScreenX(l, -(.7 * a)) + a * (1 + 2 * Math.abs(Math.sin(Math.PI * d / 2))), r))), state.simuData[s].x = n - t.xs, state.simuData[s].y = r } static addClubGrip(t, e, a, s, i) { let [l, n, r, o] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, i, e, !0), c = PhysicsCalculator.calculateClubYaw(t.yaw, t.yawGoal, t.xs, o, t.xs + t.x), u = state.isRandomColor && t.color ? t.color : null; Draw.club(Camera.projectToScreenX(l, -a), r, 0, a, !0, c, t.num, u), state.simuGripData[s].x = n - t.xs, state.simuGripData[s].y = r } static comet(t, e, a, s, i, l, n, r) { ctx.lineWidth = state.lineSize, ctx.fillStyle = l, ctx.strokeStyle = l; let o = (t - a) / n, c = (e - s) / n, u = .1 * Math.sqrt(o * o + c * c), d = Math.atan2(c, o) + Math.PI, h = u * Math.cos(d), m = u * Math.sin(d), p = h, g = m; if (r && r.length > 0) for (let x of r) { let y = state.propList.find(t => t.id === x); if (y) { p = y.tailVectorX, g = y.tailVectorY; break } } let b = p + (h - p) * .4, I = g + (m - g) * .4; if (r && r.length > 0) for (let S of r) { let $ = state.propList.find(t => t.id === S); $ && ($.tailVectorX = b, $.tailVectorY = I) } let C = Math.sqrt(b * b + I * I), D = Math.max(i / (1 + C / i), .2 * i); if (C > Math.abs(i - D)) { let f = Math.PI / 2 - Math.asin((i - D) / C), _ = i * Math.cos(f), w = i * Math.sin(f); ctx.save(), ctx.translate(t, e), ctx.rotate(Math.atan2(I, b)), ctx.beginPath(), ctx.moveTo(_, -w), ctx.lineTo(C + D * Math.cos(f), -(D * Math.sin(f))), ctx.arc(C, 0, D, -f, f), ctx.lineTo(_, w), ctx.closePath(), ctx.fill(), ctx.restore() } ctx.beginPath(), ctx.arc(t, e, i, 0, 2 * Math.PI), ctx.fill() } static addComet(t, e, a, s, i) { let [l, n, r, o] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, i, e, !1); if (r <= state.Y_INI) { let c = state.objectColor; state.isRandomColor && t.color && (c = t.color); let u = Camera.projectToScreenX(l, 0), d = Camera.projectToScreenX(t.xs == t.xg ? t.xs : state.simuData[s].x + t.xs, 0), h = state.simuData[s].y; Draw.comet(u, r, d, h, a, c, e, t.propIdList), state.isTextVisible && (ctx.fillStyle = state.textColor, ctx.font = "30px serif", ctx.fillText(String(SiteswapProcessor.CONVERT[t.num]) + (t.isCross ? "x" : ""), u + a * (1 + .1 * Math.abs(state.camPosX)), r)) } state.simuData[s].x = n - t.xs, state.simuData[s].y = r } static addCometGrip(t, e, a, s, i) { let [l, n, r, o] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, i, e, !0), c = state.objectColor; state.isRandomColor && t.color && (c = t.color); let u = Camera.projectToScreenX(l, 0), d = Camera.projectToScreenX(t.xs == t.xg ? t.xs : state.simuGripData[s].x + t.xs, 0), h = state.simuGripData[s].y; Draw.comet(u, r, d, h, a, c, e, t.propIdList), state.simuGripData[s].x = n - t.xs, state.simuGripData[s].y = r } static playerHand(t, e, a, s) { let i, l; i = t.where.vertical == HandData.DIRECTION.UP ? -1 : 1, l = t.where.horizontal == HandData.POSITION.RIGHT ? -1 : 1; let [n, r, o, c] = PhysicsCalculator.calculateParabolicTrajectory(t.num, t.xs, t.xg, t.xs + t.x, s, e, !0, i), u = state.Y_INI + 3 * state.bodySize, d = state.Y_INI - 2.5 * state.bodySize + state.bodySize / 1.5; if (u < o || d > o) { state.simuHandData[a].x = r - t.xs, state.simuHandData[a].y = o; return } state.isPlayerVisible && (ctx.lineWidth = state.lineSize, ctx.strokeStyle = state.playerColor, ctx.fillStyle = state.playerColor, ctx.beginPath(), ctx.moveTo(Camera.projectToScreenX(n, 0), o), ctx.lineTo(Camera.projectToScreenX(width / 2 + l * state.bodySize / .9 - (n - width / 2) / 5, state.bodySize * Draw.body_z[0]), state.Y_INI - state.bodySize / 1.7 + (o - state.Y_INI) / 7), ctx.stroke(), ctx.beginPath(), ctx.moveTo(Camera.projectToScreenX(width / 2 + l * state.bodySize / .9 - (n - width / 2) / 5, state.bodySize * Draw.body_z[0]), state.Y_INI - state.bodySize / 1.7 + (o - state.Y_INI) / 7), ctx.lineTo(Camera.projectToScreenX(width / 2 + l * state.bodySize / 2, state.bodySize * Draw.body_z[1]), state.Y_INI - 1.6 * state.bodySize), ctx.lineTo(Camera.projectToScreenX(width / 2 + l * state.bodySize / 12, state.bodySize * Draw.body_z[1]), state.Y_INI - 1.7 * state.bodySize), ctx.stroke(), ctx.beginPath(), ctx.arc(Camera.projectToScreenX(width / 2 + l * state.bodySize / .9 - (n - width / 2) / 5, state.bodySize * Draw.body_z[0]), state.Y_INI - state.bodySize / 1.7 + (o - state.Y_INI) / 7, .113 * state.bodySize, 0, 2 * Math.PI), ctx.fill()), state.simuHandData[a].x = r - t.xs, state.simuHandData[a].y = o } static playerBody() { state.isPlayerVisible && (ctx.lineWidth = state.lineSize, ctx.strokeStyle = state.playerColor, ctx.fillStyle = state.playerColor, ctx.beginPath(), ctx.arc(Camera.projectToScreenX(width / 2, state.bodySize * Draw.body_z[1]), state.Y_INI - 2.5 * state.bodySize + state.bodySize / 6, state.bodySize / 1.5 - state.bodySize / 6, 0, 2 * Math.PI), ctx.stroke(), ctx.beginPath(), ctx.moveTo(Camera.projectToScreenX(width / 2, state.bodySize * Draw.body_z[1]), state.Y_INI - 2.5 * state.bodySize + state.bodySize / 1.5), ctx.lineTo(Camera.projectToScreenX(width / 2, state.bodySize * Draw.body_z[1]), state.Y_INI), ctx.lineTo(Camera.projectToScreenX(width / 2 + .4 * state.bodySize, state.bodySize * Draw.body_z[1]), state.Y_INI + 3 * state.bodySize / 2), ctx.lineTo(Camera.projectToScreenX(width / 2 + .7 * state.bodySize, state.bodySize * Draw.body_z[1]), state.Y_INI + 3 * state.bodySize), ctx.lineTo(Camera.projectToScreenX(width / 2 + .6 * state.bodySize, state.bodySize * Draw.body_z[1]), state.Y_INI + 3 * state.bodySize), ctx.lineTo(Camera.projectToScreenX(width / 2 + .4 * state.bodySize, state.bodySize * Draw.body_z[1]), state.Y_INI + 3 * state.bodySize / 2), ctx.stroke(), ctx.beginPath(), ctx.moveTo(Camera.projectToScreenX(width / 2, state.bodySize * Draw.body_z[1]), state.Y_INI), ctx.lineTo(Camera.projectToScreenX(width / 2 - .4 * state.bodySize, state.bodySize * Draw.body_z[1]), state.Y_INI + 3 * state.bodySize / 2), ctx.lineTo(Camera.projectToScreenX(width / 2 - .7 * state.bodySize, state.bodySize * Draw.body_z[1]), state.Y_INI + 3 * state.bodySize), ctx.lineTo(Camera.projectToScreenX(width / 2 - .6 * state.bodySize, state.bodySize * Draw.body_z[1]), state.Y_INI + 3 * state.bodySize), ctx.lineTo(Camera.projectToScreenX(width / 2 - .4 * state.bodySize, state.bodySize * Draw.body_z[1]), state.Y_INI + 3 * state.bodySize / 2), ctx.stroke()) } static playerHandInit() { if (state.isPlayerVisible) for (let t = 0; t < 2; t++) { let e = t ? -1 : 1, a = state.x[t ? 0 : 2], s = state.Y_INI; ctx.lineWidth = state.lineSize, ctx.strokeStyle = state.playerColor, ctx.fillStyle = state.playerColor, ctx.beginPath(), ctx.moveTo(Camera.projectToScreenX(a, 0), s), ctx.lineTo(Camera.projectToScreenX(width / 2 + e * state.bodySize / .9 - (a - width / 2) / 5, state.bodySize * Draw.body_z[0]), state.Y_INI - state.bodySize / 1.7 + (s - state.Y_INI) / 7), ctx.stroke(), ctx.beginPath(), ctx.moveTo(Camera.projectToScreenX(width / 2 + e * state.bodySize / .9 - (a - width / 2) / 5, state.bodySize * Draw.body_z[0]), state.Y_INI - state.bodySize / 1.7 + (s - state.Y_INI) / 7), ctx.lineTo(Camera.projectToScreenX(width / 2 + e * state.bodySize / 2, state.bodySize * Draw.body_z[1]), state.Y_INI - 1.6 * state.bodySize), ctx.lineTo(Camera.projectToScreenX(width / 2 + e * state.bodySize / 12, state.bodySize * Draw.body_z[1]), state.Y_INI - 1.7 * state.bodySize), ctx.stroke(), ctx.beginPath(), ctx.arc(Camera.projectToScreenX(width / 2 + e * state.bodySize / .9 - (a - width / 2) / 5, state.bodySize * Draw.body_z[0]), state.Y_INI - state.bodySize / 1.7 + (s - state.Y_INI) / 7, .113 * state.bodySize, 0, 2 * Math.PI), ctx.fill() } } static bottomText(t) { ctx.fillStyle = "#FFFFFF", ctx.font = "30px serif", ctx.fillText(t, 0, height) } static topText(t) { ctx.fillStyle = "#FFFFFF", ctx.font = "30px serif", ctx.fillText(t, 0, 30) } static darkenColor(t, e) { let a = t.replace("#", ""), s = parseInt(a.substr(0, 2), 16), i = parseInt(a.substr(2, 2), 16), l = parseInt(a.substr(4, 2), 16), n = t => t.toString(16).padStart(2, "0"); return `#${n(Math.round(s * (1 - e)))}${n(Math.round(i * (1 - e)))}${n(Math.round(l * (1 - e)))}` } static renderObjectsWithDepthSorting(t, e) { let a = this.collectObjectsWithDepth(); a.sort((t, e) => e.depth - t.depth), this.renderSortedObjects(a, t, e) } static collectObjectsWithDepth() { let t = []; for (let e = 0; e < state.simuData.length; e++) { let a = state.simuData[e], { x: s, z: i } = this.calculateObjectPosition(a); t.push({ type: "airborne", index: e, data: a, depth: Camera.getDepthFromCamera3D(s, i) }) } for (let l = 0; l < state.simuGripData.length; l++) { let n = state.simuGripData[l], { x: r, z: o } = this.calculateGripObjectPosition(n); t.push({ type: "grip", index: l, data: n, depth: Camera.getDepthFromCamera3D(r, o) }) } return t } static calculateObjectPosition(t) { let e = t.xs + t.x, a = 0; if (state.objectSelect == state.DEFAULT_CONFIG.object.types.ring.value) { let s = state.ringSetting.getSetting(t.index); 2 == s && (a = this.calculateRingOuterZ(t)) } return { x: e, z: a } } static calculateGripObjectPosition(t) { let e = t.xs + t.x, a = 0; if (state.objectSelect == state.DEFAULT_CONFIG.object.types.ring.value) { let s = Array.isArray(t.index) ? t.index[0] : t.index, i = state.ringSetting.getSetting(s); 2 == i && (a = this.calculateRingOuterZ(t, !0)) } return { x: e, z: a } } static calculateRingOuterZ(t, e = !1) { let a = t.xg, s = t.xs == a; s && (a += 100); let i = a - t.xs; return ((e ? -2 : 2) * state.ballSize * (1 - t.x / i) + (e ? state.ballSize : -state.ballSize)) * 1e3 } static renderSortedObjects(t, e, a) { for (let s of t) "airborne" === s.type ? state.objectSelect == state.DEFAULT_CONFIG.object.types.ball.value ? Draw.addBall(s.data, e, state.ballSize, s.index, a) : state.objectSelect == state.DEFAULT_CONFIG.object.types.ring.value ? Draw.addRing(s.data, e, state.ballSize, s.index, a) : state.objectSelect == state.DEFAULT_CONFIG.object.types.club.value ? Draw.addClub(s.data, e, state.ballSize, s.index, a) : state.objectSelect == state.DEFAULT_CONFIG.object.types.comet.value && Draw.addComet(s.data, e, state.ballSize, s.index, a) : "grip" === s.type && (state.objectSelect == state.DEFAULT_CONFIG.object.types.ball.value ? Draw.addBallGrip(s.data, e, state.ballSize, s.index, a) : state.objectSelect == state.DEFAULT_CONFIG.object.types.ring.value ? Draw.addRingGrip(s.data, e, state.ballSize, s.index, a) : state.objectSelect == state.DEFAULT_CONFIG.object.types.club.value ? Draw.addClubGrip(s.data, e, state.ballSize, s.index, a) : state.objectSelect == state.DEFAULT_CONFIG.object.types.comet.value && Draw.addCometGrip(s.data, e, state.ballSize, s.index, a)) } } class PhysicsCalculator { static VERSION = "1.0.2"; static calculateParabolicTrajectory(t, e, a, s, i, l, n, r = 1) { let o = n ? 1 : t - 1, c = e == a; c && (a += 100); let u = a - e, d = state.G_INI, h = 1 == t ? u / animation.diffTime : u / (o * animation.diffTime), m = state.Y_INI - d * (o + 1) ** 2 / state.maxHPa; (2 == t || n) && (m = state.Y_INI - d * (o + 25.5 / state.bodySize) ** 2 / state.maxHPa), s += h * l * state.viewSpeed, s = PhysicsCalculator.correctPosition(a, s, h, i, l, n); let p = (e + a) / 2, g = (m - state.Y_INI) / ((p - e) * (p - a)), x = r * (n ? -1 : 1) * g * (s - e) * (s - a) + state.Y_INI, y = c ? e : s; return [y, s, x, u] } static correctPosition(t, e, a, s, i, l) { if (l) { if ((t - e) / a < 1 && .3 > Math.abs(1 - s - (t - e) / a)) { let n = Math.floor((1 - s) / (i * state.viewSpeed)); n = 0 == n ? 1 : n, e += (t - (1 - s) * a - e) / n } } else if ((t - e) / a < 1 && .3 > Math.abs(1 - s - (t - e) / a)) { let r = Math.floor((1 - s) / (i * state.viewSpeed)); r = 0 == r ? 1 : r, e += (t - (1 - s) * a - e) / r } else if ((t - e) / a > 1 && (t - e) / a < 2 && .3 > Math.abs(2 - s - (t - e) / a)) { let o = Math.floor(1 / (2 * i * state.viewSpeed)); o = 0 == o ? 1 : o, e += (t - (2 - s) * a - e) / o } else if ((t - e) / a > 2 && (t - e) / a < 3 && .3 > Math.abs(3 - s - (t - e) / a)) { let c = Math.floor(1 / (i * state.viewSpeed)); c = 0 == c ? 1 : c, e += (t - (3 - s) * a - e) / c } return e } static calculateRingRotation(t, e, a, s) { return (s - e) / a * 2 * t } static calculateClubRotation(t, e, a, s) { return (s - e) / a * t } static calculateClubYaw(t, e, a, s, i) { return t + (e - t) * ((i - a) / s) - state.camPosX } } class EventManager { constructor() { this.inputStringElement = document.getElementById("siteswapInput"), this.loadSiteswapBtnElement = document.getElementById("loadSiteswapBtn"), this.clubRotSettingElement = document.getElementById("clubRotSetting"), this.ringSettingElement = document.getElementById("ringSetting"), this.backgroundColorSelectElement = document.getElementById("backgroundColorSelect"), this.objectColorElement = document.getElementById("objectColor"), this.playerColorElement = document.getElementById("playerColor"), this.textColorElement = document.getElementById("textColor"), this.isPlayerVisibleElement = document.getElementById("isPlayerVisible"), this.viewSpeedElement = document.getElementById("viewSpeed"), this.isTextVisibleElement = document.getElementById("isTextVisible"), this.isRandomColorElement = document.getElementById("isRandomColor"), this.objectSelectElement = document.getElementById("objectSelect"), this.isNotStopWhenMovCamElement = document.getElementById("isNotStopWhenMovCam"), this.cameraXElement = document.getElementById("camera-x"), this.resetSpeedBtnElement = document.getElementById("resetSpeedBtn"), this.resetCameraBtnElement = document.getElementById("resetCameraBtn"), this.outputDisplayElement = document.getElementById("output-display"), this.titleWrapperElement = document.getElementById("title-wrapper") } updateObjectColorState(t) { this.objectColorElement && (this.objectColorElement.disabled = t, t ? (this.objectColorElement.style.opacity = "0.5", this.objectColorElement.style.cursor = "not-allowed") : (this.objectColorElement.style.opacity = "1", this.objectColorElement.style.cursor = "pointer")) } applyInitialValues() { this.generateObjectSelectOptions(); let t = state.DEFAULT_CONFIG; this.backgroundColorSelectElement && (this.backgroundColorSelectElement.value = t.colors.background), this.objectColorElement && (this.objectColorElement.value = t.colors.object), this.playerColorElement && (this.playerColorElement.value = t.colors.player), this.textColorElement && (this.textColorElement.value = t.colors.text), this.isPlayerVisibleElement && (this.isPlayerVisibleElement.checked = t.visibility.showPlayer), this.isTextVisibleElement && (this.isTextVisibleElement.checked = t.visibility.showText), this.isRandomColorElement && (this.isRandomColorElement.checked = t.visibility.randomColor), this.updateObjectColorState(t.visibility.randomColor), this.isNotStopWhenMovCamElement && (this.isNotStopWhenMovCamElement.checked = t.animation.continueDuringCameraMove), this.viewSpeedElement && (this.viewSpeedElement.value = t.animation.speedInput), this.cameraXElement && (this.cameraXElement.value = t.camera.positionXInput), canvas && (canvas.style.backgroundColor = t.colors.background) } generateObjectSelectOptions() { this.objectSelectElement && (this.objectSelectElement.innerHTML = "", Object.entries(state.DEFAULT_CONFIG.object.types).forEach(([t, e]) => { let a = document.createElement("option"); a.value = e.value, a.textContent = e.displayName, this.objectSelectElement.appendChild(a) }), this.objectSelectElement.value = state.DEFAULT_CONFIG.object.selected) } setupEventListeners() { let t = (t, e, a, s = !1) => { t && t.addEventListener(e, a, s) }; t(this.loadSiteswapBtnElement, "click", t => { t.preventDefault(), animation.start(this.inputStringElement?.value ?? ""), log.timeClear(), log.add(this.inputStringElement?.value ?? ""), this.inputStringElement?.value || display.update("入力欄が空欄です", "", !1) }), t(this.inputStringElement, "input", () => { animation.start(this.inputStringElement.value) }), t(this.clubRotSettingElement, "change", t => { state.clubRot.changeList(t, t.target.dataset.index) }), t(this.ringSettingElement, "change", t => { state.ringSetting.changeList(t, t.target.dataset.indexRing) }), t(this.backgroundColorSelectElement, "input", t => { state.backgroundColor = t.target.value, canvas && (canvas.style.backgroundColor = t.target.value) }), t(this.objectColorElement, "input", t => { state.objectColor = t.target.value }), t(this.playerColorElement, "input", t => { state.playerColor = t.target.value }), t(this.textColorElement, "input", t => { state.textColor = t.target.value }), t(this.isPlayerVisibleElement, "change", t => { state.isPlayerVisible = t.target.checked }), t(this.isTextVisibleElement, "change", t => { state.isTextVisible = t.target.checked }), t(this.isRandomColorElement, "change", t => { state.isRandomColor = t.target.checked, this.updateObjectColorState(t.target.checked) }), t(this.isNotStopWhenMovCamElement, "change", t => { state.isNotStopWhenMovCam = t.target.checked }), t(this.viewSpeedElement, "input", t => { state.setViewSpeed(t.target.value) }), t(this.objectSelectElement, "change", t => { state.objectSelect = t.target.value; let e = state.DEFAULT_CONFIG.object.types; state.objectSelect === e.club.value ? state.clubRot.displayInput() : state.clubRot.hiddenInput(), state.objectSelect === e.ring.value ? state.ringSetting.displayInput() : state.ringSetting.hiddenInput(), t.target.value === e.ring.value && this.cameraXElement?.value == state.DEFAULT_CONFIG.camera.positionXInput && (this.cameraXElement.value = state.DEFAULT_CONFIG.camera.positionXInputForRing, state.setCamPosX(state.DEFAULT_CONFIG.camera.positionXInputForRing)) }), t(this.inputStringElement, "focus", () => { log.show() }), t(this.inputStringElement, "blur", () => { log.hide() }), t(this.cameraXElement, "input", t => { state.setCamPosX(t.target.value) }), t(this.resetSpeedBtnElement, "click", t => { t.preventDefault(), this.viewSpeedElement && (this.viewSpeedElement.value = state.DEFAULT_CONFIG.animation.speedInput, state.setViewSpeed(state.DEFAULT_CONFIG.animation.speedInput)) }), t(this.resetCameraBtnElement, "click", t => { t.preventDefault(), this.cameraXElement && (this.cameraXElement.value = state.DEFAULT_CONFIG.camera.positionXInput, state.setCamPosX(state.DEFAULT_CONFIG.camera.positionXInput)) }), ["touchstart", "mousedown"].forEach(e => t(this.cameraXElement, e, () => { state.isNotStopWhenMovCam || state.setZeroViewSpeed() })), ["touchend", "mouseup", "mouseleave"].forEach(e => t(this.cameraXElement, e, () => { state.setViewSpeed(this.viewSpeedElement?.value) })) } restoreFromQuery(t) { t && 0 !== Object.keys(t).length && (console.log(t), t.pattern ? this.inputStringElement && (this.inputStringElement.value = t.pattern) : t.encodedPattern && this.inputStringElement && (this.inputStringElement.value = t.encodedPattern), void 0 !== t.speed && (this.viewSpeedElement && (this.viewSpeedElement.value = t.speed), state.setViewSpeed(t.speed)), void 0 !== t.camera && (this.cameraXElement && (this.cameraXElement.value = t.camera), state.setCamPosX(t.camera)), void 0 !== t.showPlayer && (this.isPlayerVisibleElement && (this.isPlayerVisibleElement.checked = t.showPlayer), state.isPlayerVisible = t.showPlayer), void 0 !== t.text && (this.isTextVisibleElement && (this.isTextVisibleElement.checked = t.text.includes("side")), state.isTextVisible = t.text.includes("side"), !t.text.includes("top") && this.outputDisplayElement && (this.outputDisplayElement.style.display = "none"), t.text.includes("bottom") && (state.isBottomTextVisible = !0)), void 0 !== t.showHeader && !t.showHeader && this.titleWrapperElement && (this.titleWrapperElement.style.display = "none"), t.object && (this.objectSelectElement && (this.objectSelectElement.value = t.object), state.objectSelect = t.object, t.object === state.DEFAULT_CONFIG.object.types.club.value ? state.clubRot.displayInput() : state.clubRot.hiddenInput(), t.object === state.DEFAULT_CONFIG.object.types.ring.value ? state.ringSetting.displayInput() : state.ringSetting.hiddenInput()), t.backgroundColor && (this.backgroundColorSelectElement && (this.backgroundColorSelectElement.value = t.backgroundColor), canvas && (canvas.style.backgroundColor = t.backgroundColor), state.backgroundColor = t.backgroundColor), t.objectColor && (this.objectColorElement && (this.objectColorElement.value = t.objectColor), state.objectColor = t.objectColor), t.playerColor && (this.playerColorElement && (this.playerColorElement.value = t.playerColor), state.playerColor = t.playerColor), t.sideTextColor && (this.textColorElement && (this.textColorElement.value = t.sideTextColor), state.textColor = t.sideTextColor), void 0 !== t.randomColor && (this.isRandomColorElement && (this.isRandomColorElement.checked = t.randomColor), state.isRandomColor = t.randomColor, this.updateObjectColorState(t.randomColor)), t.pattern ? animation.start(t.pattern) : t.encodedPattern && animation.start(t.encodedPattern)) } } class Log { constructor() { this.logDiv = document.getElementById("log"), this.storageKey = "umejugg_SSM_Log", this.timeoutDuration = 3e3, this.timeoutId = null } timeStart(t) { this.timeClear(), this.timeoutId = setTimeout(() => { this.add(t), this.timeoutId = null }, this.timeoutDuration) } timeClear() { this.timeoutId && (clearTimeout(this.timeoutId), this.timeoutId = null) } show() { try { let t = this.get(); console.log(t), t && (this.logDiv.scrollTop = 0, this.logDiv.style.maxHeight = "200px", this.logDiv.style.opacity = "1", this._addLogHtml(t)) } catch (e) { return console.error("Failed to add data:", e), !1 } } hide() { this.logDiv.style.maxHeight = "0", this.logDiv.style.opacity = "0" } _addLogHtml(t) { this.logDiv.innerHTML = "", t.reverse().forEach(t => { let e = document.createElement("a"); e.textContent = t, e.addEventListener("click", e => { e.preventDefault(), display.updateInput(t), animation.start(t) }), this.logDiv.appendChild(e) }); let e = document.createElement("a"); e.style.color = "#EC407A", e.textContent = "履歴を削除", e.addEventListener("click", t => { t.preventDefault(), this.delete(), this.hide() }), this.logDiv.appendChild(e) } _save(t) { try { let e = JSON.stringify(t); return localStorage.setItem(this.storageKey, e), !0 } catch (a) { return console.error("Failed to save data:", a), !1 } } get() { try { let t = localStorage.getItem(this.storageKey); return t ? JSON.parse(t) : null } catch (e) { return console.error("Failed to get data:", e), null } } add(t) { try { if ("string" == typeof t) { let e = t.replace(/\s+/g, ""); if ("" === e) return !1; t = e } let a = this.get(); a || (a = []); let s = a[a.length - 1]; if (s && JSON.stringify(s) === JSON.stringify(t)) return !0; for (; a.length >= 20;)a.shift(); return a.push(t), this._save(a) } catch (i) { return console.error("Failed to add data:", i), !1 } } delete() { try { return localStorage.removeItem(this.storageKey), !0 } catch (t) { return console.error("Failed to delete data:", t), !1 } } } class Camera { static rotatePoint(t, e, a, s, i) { let l = t - a, n = e - s; return { x: l * Math.cos(i) - n * Math.sin(i) + a, y: l * Math.sin(i) + n * Math.cos(i) + s } } static calculateIntersection(t, e, a, s, i) { return s - e == 0 ? (console.error("交点が計算できませんでした"), e === i) ? t : null : (-e * a + s * t + (a - t) * i) / (s - e) } static projectToScreenX(t, e) { let a = state.camPosX * Math.PI / 2, s = Camera.calculateIntersection(t, 0, state.centerX, state.camPosZ, e), i = Camera.rotatePoint(s, e, state.centerX, 0, a); return Camera.calculateIntersection(i.x, i.y, state.centerX, state.camPosZ, 0) } static getSizeRatio(t) { let e = state.camPosX * Math.PI / 2, a = Camera.rotatePoint(t, 0, state.centerX, 0, e); return 1 - a.y / (6 * state.centerX) } static getDepthFromCamera(t) { let e = state.camPosX * Math.PI / 2, a = Camera.rotatePoint(t, 0, state.centerX, 0, e); return a.y } static getDepthFromCamera3D(t, e) { let a = state.camPosX * Math.PI / 2, s = Camera.rotatePoint(t, e, state.centerX, 0, a); return s.y } } class QueryManager { static KEYS = { pattern: { key: "pattern", type: "string", validator: t => "string" == typeof t && t.length > 0 }, encodedPattern: { key: "encoded-pattern", type: "urlEncodedString", validator: t => "string" == typeof t && t.length > 0 }, speed: { key: "speed", type: "number", min: 0, max: 200, defaultValue: 100, validator(t) { let e = Number(t); return !isNaN(e) && e >= 0 && e <= 200 } }, camera: { key: "camera", type: "number", min: -100, max: 100, defaultValue: 0, validator(t) { let e = Number(t); return !isNaN(e) && e >= -100 && e <= 100 } }, object: { key: "object", type: "enum", get values() { return Object.keys(state.DEFAULT_CONFIG.object.types) }, get defaultValue() { return state.DEFAULT_CONFIG.object.selected }, validator: t => t in state.DEFAULT_CONFIG.object.types }, text: { key: "text", type: "multiEnum", values: ["none", "bottom", "top", "side"], defaultValue: "top", validator: t => Array.isArray(t) ? t.every(t => ["none", "bottom", "top", "side"].includes(t)) && t.length > 0 : ["none", "bottom", "top", "side"].includes(t) }, showHeader: { key: "show-header", type: "boolean", defaultValue: !0, validator(t) { let e = t.toLowerCase(); return ["true", "false", "1", "0"].includes(e) } }, showPlayer: { key: "show-player", type: "boolean", defaultValue: !0, validator(t) { let e = t.toLowerCase(); return ["true", "false", "1", "0"].includes(e) } }, randomColor: { key: "random-color", type: "boolean", defaultValue: !1, validator(t) { let e = t.toLowerCase(); return ["true", "false", "1", "0"].includes(e) } }, backgroundColor: { key: "background-color", type: "color", get defaultValue() { return state.DEFAULT_CONFIG.colors.background }, validator: t => /^[0-9A-Fa-f]{6}$/.test(t) }, objectColor: { key: "object-color", type: "color", get defaultValue() { return state.DEFAULT_CONFIG.colors.object }, validator: t => /^[0-9A-Fa-f]{6}$/.test(t) }, playerColor: { key: "player-color", type: "color", get defaultValue() { return state.DEFAULT_CONFIG.colors.player }, validator: t => /^[0-9A-Fa-f]{6}$/.test(t) }, sideTextColor: { key: "side-text-color", type: "color", get defaultValue() { return state.DEFAULT_CONFIG.colors.text }, validator: t => /^[0-9A-Fa-f]{6}$/.test(t) } }; static parseQuery(t) { let e = new URLSearchParams(t), a = {}; for (let [s, i] of Object.entries(QueryManager.KEYS)) { let l = e.get(i.key); if (null !== l) { let n = l; "multiEnum" === i.type && (n = l.split(",").map(t => t.trim()).filter(t => t.length > 0), (n = [...new Set(n)]).includes("none") && (n = ["none"])), i.validator(n) ? a[s] = QueryManager.convertValue(n, i.type) : console.warn(`Invalid value for ${s}: ${l}`) } } return a } static parseCurrentURL() { return QueryManager.parseQuery(window.location.search) } static convertValue(t, e) { switch (e) { case "number": return Number(t); case "boolean": let a = t.toLowerCase(); return "true" === a || "1" === a; case "color": return `#${t}`; case "urlEncodedString": return decodeURIComponent(t); default: return t } } static buildQuery(t) { let e = new URLSearchParams; for (let [a, s] of Object.entries(t)) QueryManager.KEYS[a] && void 0 !== s && e.set(QueryManager.KEYS[a].key, s.toString()); return e.toString() } static getParamInfo() { let t = {}; for (let [e, a] of Object.entries(QueryManager.KEYS)) t[e] = { key: a.key, type: a.type, defaultValue: a.defaultValue, ...void 0 !== a.min && { min: a.min }, ...void 0 !== a.max && { max: a.max }, ...a.values && { values: a.values } }; return t } static updateURL(t, e = !0) { let a = this.buildQuery(t), s = a ? `${window.location.pathname}?${a}${window.location.hash}` : `${window.location.pathname}${window.location.hash}`; e ? window.history.replaceState({}, "", s) : window.history.pushState({}, "", s) } static _parseURL(t) { try { let e = new URL(t); return QueryManager.parseQuery(e.search) } catch (a) { return console.error("Invalid URL:", a), QueryManager.getDefaultParams() } } static _validateParam(t, e) { let a = QueryManager.KEYS[t]; return !!a && a.validator(e) } static _getDefaultParams() { let t = {}; for (let [e, a] of Object.entries(QueryManager.KEYS)) t[e] = a.defaultValue; return t } } class Color { static calculateLandingHand(t, e) { if (e) return null; let a = 0 === t.handIndex || 1 === t.handIndex, s; return t.isCross ? a ? HandData.POSITION.LEFT : HandData.POSITION.RIGHT : a ? HandData.POSITION.RIGHT : HandData.POSITION.LEFT } static assignColorToItem(t, e, a) { let s = t.count + t.num, i = this.calculateLandingHand(t, a), l = null; a || (l = 0 === t.handIndex || 1 === t.handIndex ? HandData.POSITION.RIGHT : HandData.POSITION.LEFT); let n = e.find(e => e.landingCount === t.count && e.landingHand === l); if (n) t.color = n.color, t.colorId = n.id, n.landingCount = s, n.num = t.num, n.landingHand = i; else { let r = e.find(t => null === t.landingCount); r ? (t.color = r.color, t.colorId = r.id, r.landingCount = s, r.num = t.num, r.landingHand = i) : console.error("エラー: colorListに空きスロットが見つかりません", { item: t, colorList: e }) } } static getColorForGripItem(t, e, a) { let s = this.calculateLandingHand(t, a), i = e.findLast(e => e.landingCount === t.count && e.landingHand === s && 1 !== e.num); i || (i = e.findLast(e => e.landingCount === t.count && e.landingHand === s)), i ? (t.color = i.color, t.colorId = i.id) : console.error("エラー: 一致するcolorListエントリが見つかりません", { item: t, colorList: e, landingHand: s }) } static createInitialData(t) { let e = state.backgroundColor || "#5a5a5a", a = this.generateDistinctColorsWithBackground(t, e), s = []; for (let i = 0; i < t; i++)s.push({ id: i, color: a[i], landingCount: null }); return s } static generateDistinctColorsWithBackground(t, e) { if (t <= 0) return []; let a = this.colorToHsl(e), s; s = a.l < .5 ? .65 : .45; let i = .85; if (1 === t) { let l = (a.h + .5) % 1, n = this.hslToRgb(l, i, s); return [`rgb(${n.r}, ${n.g}, ${n.b})`] } let r = [], o = (a.h + .5) % 1; for (let c = 0; c < t; c++) { let u = this.hslToRgb(o, i, s); r.push(`rgb(${u.r}, ${u.g}, ${u.b})`), o += .618033988749895, o %= 1 } return r } static generateDistinctColorsWithGoldenRatio(t) { if (t <= 0) return []; if (1 === t) return ["rgb(255, 0, 0)"]; let e = [], a = .85, s = .55, i = Math.random(); for (let l = 0; l < t; l++) { let n = this.hslToRgb(i, a, s); e.push(`rgb(${n.r}, ${n.g}, ${n.b})`), i += .618033988749895, i %= 1 } return e } static generateDistinctColors(t) { if (t <= 0) return []; if (1 === t) return ["rgb(255, 0, 0)"]; let e = []; for (let a = 0; a < t; a++) { let s = a / t, i = this.hslToRgb(s, .85, .55); e.push(`rgb(${i.r}, ${i.g}, ${i.b})`) } return e } static colorToHsl(t) { let e, a, s; if (t.startsWith("#")) { let i = t.replace("#", ""); e = parseInt(i.substr(0, 2), 16) / 255, a = parseInt(i.substr(2, 2), 16) / 255, s = parseInt(i.substr(4, 2), 16) / 255 } else { if (!t.startsWith("rgb")) return { h: 0, s: 0, l: .5 }; let l = t.match(/\d+/g); if (!l || !(l.length >= 3)) return { h: 0, s: 0, l: .5 }; e = parseInt(l[0]) / 255, a = parseInt(l[1]) / 255, s = parseInt(l[2]) / 255 } return this.rgbToHsl(e, a, s) } static rgbToHsl(t, e, a) { let s = Math.max(t, e, a), i = Math.min(t, e, a), l = (s + i) / 2; if (s === i) return { h: 0, s: 0, l }; let n = s - i, r; switch (s) { case t: r = ((e - a) / n + (e < a ? 6 : 0)) / 6; break; case e: r = ((a - t) / n + 2) / 6; break; case a: r = ((t - e) / n + 4) / 6 }return { h: r, s: l > .5 ? n / (2 - s - i) : n / (s + i), l } } static hslToRgb(t, e, a) { let s, i, l; if (0 === e) s = i = l = a; else { let n = (t, e, a) => (a < 0 && (a += 1), a > 1 && (a -= 1), a < 1 / 6) ? t + (e - t) * 6 * a : a < .5 ? e : a < 2 / 3 ? t + (e - t) * (2 / 3 - a) * 6 : t, r = a < .5 ? a * (1 + e) : a + e - a * e, o = 2 * a - r; s = n(o, r, t + 1 / 3), i = n(o, r, t), l = n(o, r, t - 1 / 3) } return { r: Math.round(255 * s), g: Math.round(255 * i), b: Math.round(255 * l) } } } class Prop { static calculateLandingHand(t, e) { if (e) return null; let a = 0 === t.handIndex || 1 === t.handIndex, s; return t.isCross ? a ? HandData.POSITION.LEFT : HandData.POSITION.RIGHT : a ? HandData.POSITION.RIGHT : HandData.POSITION.LEFT } static assignPropIdToItem(t, e, a) { let s = t.count + t.num, i = this.calculateLandingHand(t, a), l = null; a || (l = 0 === t.handIndex || 1 === t.handIndex ? HandData.POSITION.RIGHT : HandData.POSITION.LEFT); let n = e.find(e => e.landingCount === t.count && e.landingHand === l); if (n) t.propIdList = [n.id], n.landingCount = s, n.num = t.num, n.landingHand = i; else { let r = e.find(t => null === t.landingCount); r ? (t.propIdList = [r.id], r.landingCount = s, r.num = t.num, r.landingHand = i) : console.error("エラー: propListに空きスロットが見つかりません", { item: t, propList: e }) } } static getPropIdForGripItem(t, e, a) { let s = this.calculateLandingHand(t, a), i = e.filter(e => e.landingCount === t.count && e.landingHand === s && 1 !== e.num); i.length > 0 ? t.propIdList = i.map(t => t.id) : console.error("エラー: 一致するpropListエントリが見つかりません", { item: t, propList: e, landingHand: s }) } static createInitialData(t) { let e = []; for (let a = 0; a < t; a++)e.push({ id: a, landingCount: null, tailVectorX: 0, tailVectorY: 0 }); return e } } class PatternFeatures { constructor() { this.currentPage = 1, this.itemsPerPage = 10, this.allConnectionsData = [], this.setupEventListeners() } setupEventListeners() { let t = document.getElementById("showAllConnectionsBtn"); t && t.addEventListener("click", t => { t.preventDefault(); let e = document.getElementById("siteswapInput").value; this.calculateAllConnections(e) }); let e = document.getElementById("prevPage"), a = document.getElementById("nextPage"); e && e.addEventListener("click", () => { this.currentPage > 1 && (this.currentPage--, this.displayConnections(this.currentPage)) }), a && a.addEventListener("click", () => { let t = Math.ceil(this.allConnectionsData.length / this.itemsPerPage); this.currentPage < t && (this.currentPage++, this.displayConnections(this.currentPage)) }) } update(t, e) { let a = document.getElementById("pattern-error"), s = document.getElementById("pattern-loading"), i = document.getElementById("features-result"); if (!a || !s || !i || "undefined" == typeof SiteswapLab) return; a.style.display = "none", a.textContent = ""; let l = document.getElementById("all-connections-error"); l && (l.style.display = "none", l.textContent = ""), i.style.display = "none"; let n = document.getElementById("connection-info"); n && (n.style.display = "none"); let r = document.getElementById("all-connections"); r && (r.style.display = "none"), t && "" !== t.trim() && (s.style.display = "block", setTimeout(() => { try { if (!e) { a.textContent = "有効なサイトスワップパターンではありません", a.style.display = "block", s.style.display = "none"; return } let l = SiteswapLab.analyzePattern(t); if (l.isValid && l.isJugglable) { let r = (t, e) => { let a = document.getElementById(t); a && (a.textContent = e) }; if (r("feature-inputPattern", t), r("feature-propCount", l.data.propCount + "個"), r("feature-maxHeight", l.data.maxHeight), r("feature-period", l.data.period), r("feature-patternType", l.data.isAsync ? "アシンクロ" : "シンクロ"), r("feature-state", "[" + l.data.state.join(", ") + "]"), n) try { let o = SiteswapLab.calculateConnectionPattern("", t); if (o.isValid && o.isJugglable) { let c = o.data.pattern1; r("feature-groundState", c); let u = o.data.connection; r("feature-connectionPattern", u || "直接入れる（接続投げ不要）"); let d = o.data.reverseConnection; r("feature-reverseConnection", d || "直接入れる（接続投げ不要）"); let h = o.data.fullConnection; r("feature-fullConnection", h), n.style.display = "block" } else n.style.display = "none" } catch (m) { console.error("接続計算エラー:", m), n.style.display = "none" } i.style.display = "block" } else a.textContent = "有効なサイトスワップパターンではありません: " + (l.message || ""), a.style.display = "block", i.style.display = "none" } catch (p) { console.error("解析エラー:", p), a.textContent = "エラーが発生しました: " + p.message, a.style.display = "block", i.style.display = "none" } finally { s.style.display = "none" } }, 100)) } calculateAllConnections(t) { let e = document.getElementById("all-connections-error"), a = document.getElementById("all-connections-loading"), s = document.getElementById("all-connections"); e && a && s && "undefined" != typeof SiteswapLab && (e.style.display = "none", e.textContent = "", s.style.display = "none", a.style.display = "block", setTimeout(() => { try { let i = SiteswapLab.calculateAllConnectionPatterns("", t); if (i.isValid && i.isJugglable) { this.allConnectionsData = i.data.connections; let l = this.allConnectionsData.length, n = document.getElementById("total-connections"); n && (n.textContent = l), this.currentPage = 1, this.displayConnections(this.currentPage), s.style.display = "block", i.data.calculationError && (e.textContent = "警告: " + i.data.calculationError, e.style.display = "block") } else e.textContent = "すべての接続を計算できませんでした: " + (i.message || ""), e.style.display = "block" } catch (r) { console.error("すべての接続計算エラー:", r), e.textContent = "エラーが発生しました: " + r.message, e.style.display = "block" } finally { a.style.display = "none" } }, 100)) } displayConnections(t) { let e = document.getElementById("connections-list"), a = document.getElementById("pagination"); if (!e || !a) return; let s = Math.ceil(this.allConnectionsData.length / this.itemsPerPage), i = (t - 1) * this.itemsPerPage, l = Math.min(i + this.itemsPerPage, this.allConnectionsData.length); e.innerHTML = ""; for (let n = i; n < l; n++) { let r = document.createElement("div"); r.style.padding = "8px", r.style.marginBottom = "5px", r.style.backgroundColor = "#DBE2EF", r.style.borderRadius = "5px", r.style.wordBreak = "break-all", r.innerHTML = `<strong>${n + 1}:</strong> ${this.allConnectionsData[n]}`, e.appendChild(r) } if (s > 1) { a.style.display = "block"; let o = document.getElementById("pageInfo"); o && (o.textContent = `${t} / ${s}`); let c = document.getElementById("prevPage"), u = document.getElementById("nextPage"); c && (c.disabled = 1 === t), u && (u.disabled = t === s) } else a.style.display = "none" } } class Test { constructor() { this.init() } init() { window.addEventListener("load", () => { animation.load(), animation.start("7-5+6"), state.objectSelect = state.DEFAULT_CONFIG.object.types.ball.value, state.isPlayerVisible = !0, state.isTextVisible = !0, state.viewSpeed = 3, canvas.scrollIntoView({ behavior: "smooth", block: "start" }) }) } } const canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d"), width = canvas.width, height = canvas.height, state = new State, log = new Log, animation = new Animation, eventManager = new EventManager, display = new Display, syncPatternInput = void 0 !== window.SyncPatternInput ? new window.SyncPatternInput : null, patternFeatures = new PatternFeatures; eventManager.applyInitialValues(), eventManager.setupEventListeners(), window.addEventListener("load", () => { animation.load(), eventManager.restoreFromQuery(QueryManager.parseCurrentURL()) });